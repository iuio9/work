/* eslint-disable */
/* prettier-ignore */
// Generated by elegant-router
// Read more: https://github.com/soybeanjs/elegant-router

import type { RouteRecordRaw, RouteComponent } from 'vue-router';
import type { ElegantConstRoute } from '@elegant-router/vue';
import type { RouteMap, RouteKey, RoutePath } from '@elegant-router/types';

/**
 * transform elegant const routes to vue routes
 * @param routes elegant const routes
 * @param layouts layout components
 * @param views view components
 */
export function transformElegantRoutesToVueRoutes(
  routes: ElegantConstRoute[],
  layouts: Record<string, RouteComponent | (() => Promise<RouteComponent>)>,
  views: Record<string, RouteComponent | (() => Promise<RouteComponent>)>
) {
  return routes.flatMap(route => transformElegantRouteToVueRoute(route, layouts, views));
}

/**
 * transform elegant route to vue route
 * @param route elegant const route
 * @param layouts layout components
 * @param views view components
 */
function transformElegantRouteToVueRoute(
  route: ElegantConstRoute,
  layouts: Record<string, RouteComponent | (() => Promise<RouteComponent>)>,
  views: Record<string, RouteComponent | (() => Promise<RouteComponent>)>
) {
  const LAYOUT_PREFIX = 'layout.';
  const VIEW_PREFIX = 'view.';
  const ROUTE_DEGREE_SPLITTER = '_';
  const FIRST_LEVEL_ROUTE_COMPONENT_SPLIT = '$';

  function isLayout(component: string) {
    return component.startsWith(LAYOUT_PREFIX);
  }

  function getLayoutName(component: string) {
    const layout = component.replace(LAYOUT_PREFIX, '');

    if(!layouts[layout]) {
      throw new Error(`Layout component "${layout}" not found`);
    }

    return layout;
  }

  function isView(component: string) {
    return component.startsWith(VIEW_PREFIX);
  }

  function getViewName(component: string) {
    const view = component.replace(VIEW_PREFIX, '');

    if(!views[view]) {
      throw new Error(`View component "${view}" not found`);
    }

    return view;
  }

  function isFirstLevelRoute(item: ElegantConstRoute) {
    return !item.name.includes(ROUTE_DEGREE_SPLITTER);
  }

  function isSingleLevelRoute(item: ElegantConstRoute) {
    return isFirstLevelRoute(item) && !item.children?.length;
  }

  function getSingleLevelRouteComponent(component: string) {
    const [layout, view] = component.split(FIRST_LEVEL_ROUTE_COMPONENT_SPLIT);

    return {
      layout: getLayoutName(layout),
      view: getViewName(view)
    };
  }

  const vueRoutes: RouteRecordRaw[] = [];

  // add props: true to route
  if (route.path.includes(':') && !route.props) {
    route.props = true;
  }

  const { name, path, component, children, ...rest } = route;

  const vueRoute = { name, path, ...rest } as RouteRecordRaw;

  try {
    if (component) {
      if (isSingleLevelRoute(route)) {
        const { layout, view } = getSingleLevelRouteComponent(component);

        const singleLevelRoute: RouteRecordRaw = {
          path,
          component: layouts[layout],
          meta: {
            title: route.meta?.title || ''
          },
          children: [
            {
              name,
              path: '',
              component: views[view],
              ...rest
            } as RouteRecordRaw
          ]
        };

        return [singleLevelRoute];
      }

      if (isLayout(component)) {
        const layoutName = getLayoutName(component);

        vueRoute.component = layouts[layoutName];
      }

      if (isView(component)) {
        const viewName = getViewName(component);

        vueRoute.component = views[viewName];
      }

    }
  } catch (error: any) {
    console.error(`Error transforming route "${route.name}": ${error.toString()}`);
    return [];
  }

  // add redirect to child
  if (children?.length && !vueRoute.redirect) {
    vueRoute.redirect = {
      name: children[0].name
    };
  }

  if (children?.length) {
    const childRoutes = children.flatMap(child => transformElegantRouteToVueRoute(child, layouts, views));

    if(isFirstLevelRoute(route)) {
      vueRoute.children = childRoutes;
    } else {
      vueRoutes.push(...childRoutes);
    }
  }

  vueRoutes.unshift(vueRoute);

  return vueRoutes;
}

/**
 * map of route name and route path
 */
const routeMap: RouteMap = {
  "root": "/",
  "not-found": "/:pathMatch(.*)*",
  "exception": "/exception",
  "exception_403": "/exception/403",
  "exception_404": "/exception/404",
  "exception_500": "/exception/500",
  "document": "/document",
  "document_project": "/document/project",
  "document_project-link": "/document/project-link",
  "document_vue": "/document/vue",
  "document_vite": "/document/vite",
  "document_unocss": "/document/unocss",
  "document_naive": "/document/naive",
  "document_antd": "/document/antd",
  "403": "/403",
  "404": "/404",
  "500": "/500",
  "boxpulse": "/boxpulse",
  "boxpulse_code-test": "/boxpulse/code-test",
  "boxpulse_test": "/boxpulse/test",
  "data-ano": "/data-ano",
  "data-ano_autoano": "/data-ano/autoano",
  "data-ano_detail": "/data-ano/detail",
  "data-ano_group": "/data-ano/group",
  "data-ano_groupmanage": "/data-ano/groupmanage",
  "data-ano_gtag": "/data-ano/gtag",
  "data-ano_imgoperate": "/data-ano/imgoperate",
  "data-ano_mulano": "/data-ano/mulano",
  "data-ano_mulanotask": "/data-ano/mulanotask",
  "data-ano_online": "/data-ano/online",
  "data-ano_operation": "/data-ano/operation",
  "data-expansion": "/data-expansion",
  "data-expansion_add": "/data-expansion/add",
  "data-expansion_addmap": "/data-expansion/addmap",
  "data-expansion_errarea": "/data-expansion/errarea",
  "data-expansion_exportres": "/data-expansion/exportres",
  "data-expansion_extend": "/data-expansion/extend",
  "data-expansion_imgopmaster": "/data-expansion/imgopmaster",
  "data-expansion_imgtask": "/data-expansion/imgtask",
  "data-expansion_scenechange": "/data-expansion/scenechange",
  "data-manage": "/data-manage",
  "data-manage_detail": "/data-manage/detail",
  "data-manage_export": "/data-manage/export",
  "data-manage_import": "/data-manage/import",
  "data-manage_list": "/data-manage/list",
  "data-manage_map": "/data-manage/map",
  "data-manage_maplist": "/data-manage/maplist",
  "data-manage_operation": "/data-manage/operation",
  "dataset": "/dataset",
  "dataset_operate": "/dataset/operate",
  "dataset_taggroupmanager": "/dataset/taggroupmanager",
  "home": "/home",
  "login": "/login/:module(pwd-login|code-login|register|reset-pwd|bind-wechat)?",
  "manage": "/manage",
  "manage_dept": "/manage/dept",
  "manage_dict": "/manage/dict",
  "manage_dict-type": "/manage/dict-type",
  "manage_log": "/manage/log",
  "manage_log_login": "/manage/log/login",
  "manage_log_operate": "/manage/log/operate",
  "manage_menu": "/manage/menu",
  "manage_modelconfig": "/manage/modelconfig",
  "manage_role": "/manage/role",
  "manage_user": "/manage/user",
  "manage_user-detail": "/manage/user-detail/:id",
  "model": "/model",
  "model_create": "/model/create",
  "model_info": "/model/info",
  "model-manage": "/model-manage",
  "model-manage_assess": "/model-manage/assess",
  "model-manage_config": "/model-manage/config",
  "model-manage_createtask": "/model-manage/createtask",
  "model-manage_default": "/model-manage/default",
  "model-manage_prevassess": "/model-manage/prevassess",
  "model-manage_prevassessoperate": "/model-manage/prevassessoperate",
  "model-manage_thirdpartyevaluation": "/model-manage/thirdpartyevaluation",
  "model-manage_thirdpartymodel": "/model-manage/thirdpartymodel",
  "model-manage_train": "/model-manage/train",
  "model-manage_federated": "/model-manage/federated",
  "target-monitor": "/target-monitor",
  "target-monitor_modelinference": "/target-monitor/modelinference",
  "thirdparty": "/thirdparty",
  "thirdparty_approve": "/thirdparty/approve",
  "thirdparty_assess": "/thirdparty/assess",
  "thirdparty_createtask": "/thirdparty/createtask",
  "thirdparty_info": "/thirdparty/info",
  "thirdparty_model": "/thirdparty/model",
  "thirdparty_modelmanage": "/thirdparty/modelmanage",
  "thirdparty_modeloperate": "/thirdparty/modeloperate",
  "thirdparty_operate": "/thirdparty/operate",
  "thirdparty_prevassess": "/thirdparty/prevassess",
  "thirdparty_report": "/thirdparty/report",
  "thirdparty_test": "/thirdparty/test"
};

/**
 * get route path by route name
 * @param name route name
 */
export function getRoutePath<T extends RouteKey>(name: T) {
  return routeMap[name];
}

/**
 * get route name by route path
 * @param path route path
 */
export function getRouteName(path: RoutePath) {
  const routeEntries = Object.entries(routeMap) as [RouteKey, RoutePath][];

  const routeName: RouteKey | null = routeEntries.find(([, routePath]) => routePath === path)?.[0] || null;

  return routeName;
}
